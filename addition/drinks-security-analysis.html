<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>Аналіз безпеки HTML-сторінки обліку напоїв</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      line-height: 1.6;
      margin: 0;
      padding: 2rem;
      background: #f5f5f7;
      color: #222;
    }
    main {
      max-width: 960px;
      margin: 0 auto;
      background: #ffffff;
      padding: 2rem 2.5rem;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.06);
    }
    h1, h2, h3 {
      color: #111827;
    }
    h1 {
      font-size: 1.8rem;
      margin-top: 0;
      margin-bottom: 1rem;
    }
    h2 {
      font-size: 1.4rem;
      margin-top: 2rem;
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 0.25rem;
    }
    h3 {
      font-size: 1.15rem;
      margin-top: 1.2rem;
    }
    code {
      font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: #f3f4f6;
      padding: 0.15rem 0.35rem;
      border-radius: 4px;
      font-size: 0.9em;
    }
    pre {
      background: #4b5563;
      color: #e5e7eb;
      padding: 1rem 1.25rem;
      border-radius: 10px;
      overflow-x: auto;
      font-size: 0.9em;
    }
    pre code {
      background: transparent;
      padding: 0;
    }
    ul {
      padding-left: 1.25rem;
    }
    li {
      margin-bottom: 0.35rem;
    }
    .tag {
      display: inline-block;
      padding: 0.1rem 0.5rem;
      border-radius: 999px;
      background: #eef2ff;
      color: #3730a3;
      font-size: 0.8rem;
      margin-left: 0.35rem;
    }
    .section-note {
      font-size: 0.95rem;
      color: #4b5563;
      background: #f9fafb;
      border-left: 3px solid #60a5fa;
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      margin: 1rem 0;
    }
    footer {
      margin-top: 2.5rem;
      font-size: 0.9rem;
      color: #6b7280;
    }
  </style>
</head>
<body>
<main>
  <h1>Аналіз безпеки HTML-сторінки обліку напоїв</h1>

  <p><strong>Коротко:</strong> сторінка повністю клієнтська, без мережевих запитів і без бекенду, тому класичних «зламів сервера» тут немає. Основний ризик — XSS та підміна даних через резервні копії та <code>localStorage</code>.</p>

  <h2>1. Потенційні вразливості</h2>

  <h3>1.1. XSS через <code>innerHTML</code> + імпорт backup-файлу</h3>

  <p>У багатьох місцях DOM будується через <code>innerHTML</code>, куди підставляються значення з масивів <code>drinks</code>, <code>sizes</code>, <code>prices</code>, <code>orders</code>:</p>

  <ul>
    <li><code>updateSelects()</code>:
      <pre><code class="language-js">// приклад
drinkSelect.innerHTML = drinks.map(d =&gt; `&lt;option&gt;${d}&lt;/option&gt;`).join("");
sizeSelect.innerHTML  = sizes.map(s =&gt; `&lt;option&gt;${s}&lt;/option&gt;`).join("");</code></pre>
    </li>
    <li><code>renderModalLists()</code> — формує, наприклад:
      <pre><code class="language-html">&lt;input value="${d}"&gt;
&lt;span&gt;${s}&lt;/span&gt;
&lt;span&gt;${p.drink} — ${p.size}: ${p.price}&lt;/span&gt;</code></pre>
    </li>
    <li><code>renderOrders()</code> — формує рядки таблиці через шаблонні рядки:
      <pre><code class="language-js">// спрощений приклад
row.innerHTML = `
  &lt;td&gt;${o.date}&lt;/td&gt;
  &lt;td&gt;${o.name}&lt;/td&gt;
  &lt;td&gt;${o.size}&lt;/td&gt;
`;</code></pre>
    </li>
  </ul>

  <p>Звичайний користувач вводить це руками — це безпечно. Але напади починаються там, де з’являється ворожий backup-файл:</p>

  <pre><code class="language-js">function importData(event) {
  const data = JSON.parse(e.target.result);
  if (Array.isArray(data.drinks)) drinks = data.drinks;
  ...
  if (Array.isArray(data.orders)) orders = data.orders;
  ...
  renderOrders();
}</code></pre>

  <p><strong>Сценарій атаки:</strong></p>
  <ol>
    <li>Зловмисник готує <code>coffee-data-backup.json</code>, де в <code>drinks</code>, <code>sizes</code> або <code>orders.name</code> записує щось на кшталт:
      <pre><code class="language-json">"drinks": ["&lt;img src=x onerror=alert('XSS')&gt;"]</code></pre>
    </li>
    <li>Користувач імпортує цей файл (вважаючи його «оновленою версією даних»).</li>
    <li>Значення без екранування потрапляють у <code>innerHTML</code>, і браузер виконує JS у контексті сторінки (XSS).</li>
  </ol>

  <p>Що може зробити такий скрипт:</p>
  <ul>
    <li>читати та змінювати дані в <code>localStorage</code>;</li>
    <li>підміняти вміст сторінки, показувати фейкові повідомлення;</li>
    <li>якщо сторінка лежить на домені разом з іншими сервісами — читати їхні cookies / локальні дані (Same Origin).</li>
  </ul>

  <h3>1.2. Відсутня валідація вмісту backup-файлу</h3>

  <p><code>importData</code> перевіряє лише те, що значення — масиви, але не:</p>
  <ul>
    <li>максимальну довжину рядків;</li>
    <li>дозволений набір символів;</li>
    <li>типи полів усередині <code>orders</code> (наприклад, <code>price</code> може бути рядком із HTML/JS);</li>
    <li>логічні обмеження (діапазон дат, кількості, ціни).</li>
  </ul>

  <p>Це спрощує:</p>
  <ul>
    <li>XSS (див. п. 1.1);</li>
    <li>створення «бомби з даних» — тисячі записів та гігантські рядки, через які браузер почне лагати або зависати.</li>
  </ul>

  <h3>1.3. <code>localStorage</code> як точка підміни даних</h3>

  <p>Дані зберігаються в <code>localStorage</code>:</p>

  <pre><code class="language-js">localStorage.setItem(STORAGE_DRINKS, JSON.stringify(drinks));
...
orders = JSON.parse(localStorage.getItem(STORAGE_ORDERS) || "[]");</code></pre>

  <p>Особливості:</p>
  <ul>
    <li><code>localStorage</code> доступний будь-якому JS на цьому ж домені.</li>
    <li>Якщо на сторінку коли-небудь додадуть сторонній скрипт (аналітика, реклама, віджет), він зможе:
      <ul>
        <li>читати список замовлень;</li>
        <li>змінювати ціни, назви напоїв, розміри;</li>
        <li>підготувати XSS через підміну значень, які потім потрапляють у <code>innerHTML</code>.</li>
      </ul>
    </li>
  </ul>

  <p>Для локального файлу (<code>file://</code>) ризик мінімальний, але якщо ви розмістите цю сторінку на сайті з іншими скриптами — це вже повноцінна поверхня атаки.</p>

  <h3>1.4. Логічні та захисні недоліки</h3>

  <p>Це не прямий «взлом», але важливі моменти:</p>
  <ul>
    <li>Будь-хто, хто має доступ до браузера, може:
      <ul>
        <li>очистити всі записи (кнопка «Очистити список»);</li>
        <li>імпортувати інший backup і фактично знищити або підмінити історію.</li>
      </ul>
    </li>
    <li>Немає попереднього перегляду при імпорті — дані одразу перезаписуються.</li>
    <li>Немає обмежень на діапазони чисел (ціна, кількість), що може ламати інтерфейс або звіти.</li>
  </ul>

  <h2>2. Рекомендації щодо виправлення</h2>

  <h3>2.1. Прибрати <code>innerHTML</code> для користувацьких даних</h3>

  <p>Замість шаблонних рядків краще створювати елементи через <code>document.createElement</code> і заповнювати <code>textContent</code>/<code>value</code>:</p>

  <pre><code class="language-js">// було
drinkSelect.innerHTML = drinks.map(d =&gt; `&lt;option&gt;${d}&lt;/option&gt;`).join("");

// краще
drinkSelect.innerHTML = "";
drinks.forEach(d =&gt; {
  const opt = document.createElement("option");
  opt.textContent = d; // екранує HTML
  drinkSelect.appendChild(opt);
});</code></pre>

  <p>Ту саму ідеологію варто застосувати для:</p>
  <ul>
    <li><code>sizeSelect</code>;</li>
    <li><code>priceDrinkSelect</code>, <code>priceSizeSelect</code>;</li>
    <li>списків у модальних вікнах (<code>renderModalLists()</code>);</li>
    <li>таблиці замовлень (<code>renderOrders()</code>).</li>
  </ul>

  <p>Це майже повністю прибере XSS, навіть якщо в backup-файлі буде шкідливий текст.</p>

  <p>Якщо потрібно лишити шаблонні рядки, можна додати helper-екранізатор:</p>

  <pre><code class="language-js">function escapeHtml(str) {
  return String(str)
    .replace(/&amp;/g, "&amp;amp;")
    .replace(/&lt;/g, "&amp;lt;")
    .replace(/&gt;/g, "&amp;gt;")
    .replace(/"/g, "&amp;quot;")
    .replace(/'/g, "&#39;");
}</code></pre>

  <p>і всюди обгортати значення: <code>${escapeHtml(value)}</code>.</p>

  <h3>2.2. Жорсткіша перевірка backup-файлу</h3>

  <p>Перед прийманням даних варто:</p>
  <ul>
    <li>перевіряти структуру:
      <pre><code class="language-js">if (!Array.isArray(data.drinks) || !Array.isArray(data.orders)) {
  throw new Error("Невірний формат backup-файлу");
}</code></pre>
    </li>
    <li>фільтрувати дані:
      <ul>
        <li>обрізати довжину рядків (наприклад, максимум 100 символів для назви);</li>
        <li>дозволяти тільки безпечні символи (наприклад, через RegExp);</li>
        <li>приводити <code>price</code>, <code>q</code> до числа та відкидати нереалістичні значення.</li>
      </ul>
    </li>
  </ul>

  <h3>2.3. Явно попередити про довіру до backup-файлів</h3>

  <p>На рівні інтерфейсу варто додати попередження біля кнопки імпорту, наприклад:</p>

  <div class="section-note">
    «Імпортуйте тільки файли, які були створені саме цією програмою та зберігаються у вас. Не відкривайте файли з невідомих джерел.»
  </div>

  <p>Таким чином ви чесно позначите, що backup-файл — це довірене джерело даних, а не «що завгодно з інтернету».</p>

  <h3>2.4. Обмеження прав і контексту при розгортанні</h3>

  <p>Якщо сторінка буде розміщена на реальному сайті або працюватиме разом із сторонніми скриптами, бажано:</p>
  <ul>
    <li>розмістити її на окремому домені / субдомені, щоб ізолювати <code>localStorage</code> із замовленнями від інших частин сайту;</li>
    <li>налаштувати CSP (Content Security Policy), що забороняє inline-скрипти та сторонні JS-джерела, якщо це можливо.</li>
  </ul>

  <h2>3. Підсумок</h2>

  <ul>
    <li>Прямих «дір» типу SQL-інʼєкцій або крадіжки паролів немає — відсутній бекенд.</li>
    <li>Головний реальний ризик: XSS через шкідливий backup-файл у комбінації з використанням <code>innerHTML</code> без екранування.</li>
    <li>Додаткові ризики повʼязані з конфіденційністю та цілісністю даних у <code>localStorage</code>, якщо сторінка буде жити на домені разом з іншим кодом.</li>
  </ul>

  <p>Реалізація рекомендацій із розділу 2 значно зменшить поверхню атаки та зробить застосунок стійкішим до зловмисних даних.</p>

  <h2>4. Джерела інформації</h2>
  <ul>
    <li>Вихідний код HTML-файлу обліку напоїв, наданий користувачем.</li>
  </ul>

  <footer>
    Звіт згенеровано автоматично на основі аналізу вихідного коду клієнтського HTML/JS-застосунку.
  </footer>
</main>
</body>
</html>
